\section{Solution}

\subsection{Overall architecture}

\begin{itemize}
    \item \textbf{EmbeddedSystemX} Is the overall class which implementes all functionality of the application.
    Any user interaction is done through a simple text based user interface written in the main function.
\end{itemize}

To avoid unncessary C++ semantics, the entire composition of EmbeddedSystemX and all its subcomponents
is written in one large \textit{cpp} file, this is has mainly been done to reduce compiler complexity and
and practical implementation difficulties, which is bound to arise, due to things such as \textit{circular-referencing}. 
\\
\subsubsection{State Diagram} 
The overall structure follows the provided model of the system, seen on figure \ref{fig:overallStatemachine}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.4\textwidth]{pictures/state_machine.png}
    \caption{Overall statemachine of EmbeddedSystemX}
    \label{fig:overallStatemachine}
\end{figure}

% There is a focus on the inner statemachine inside of the \textit{Operational} class, which contains a nested statemachien
% In this case referred to as \textit{opFsm - operational state machine}.
There is a focus on the statemachine inside of the \textit{Operational} state. This statemachine is referred to as \textit{opFsm - operational state machine}.
\\
\subsubsection{Class Diagram}
To comform with the requirement of the GOF state machine, all of the states are implemented as classes, which are 
inheriting from the \textit{State}-class, see figure \ref{fig:classDiagram}.

\clearpage
\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\textwidth]{pictures/class_diagram.png}
    \caption{The State class, is a pure virtual class, which will be explained in a later section}
    \label{fig:classDiagram}
\end{figure}

The states are implemented this way, so that the statemachine trusts the state class with all
the behavior of the implemented classes, this means that they all have the some core
functions: \textit{eventHandler, onEntry, onExit} and so on. % It only fits together with the 
% the singleton pattern. So no matter what iteration of the state class, there only exists
% one instance of that class, that has the same public interface as the previous instance.
It only fits together with the singleton pattern, which ensures that there will only ever be
one of each state class and therefore stays consistent with previous interactions with that state class.

\clearpage

\subsubsection{Sequence Diagram}
The sequence of execution in the overall state machine is seen on figure \ref{fig:sequenceEmbedX}.
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.5\textwidth]{pictures/sequence_embeddedSysX.png}
    \caption{The initial phase of the EmbeddedSystemX's statemachine, here it automatically
    executes through the initial states. A small chance has been added so that the SelfTest
    might fail. Otherwise it justs continues to the ready state. It also shows the lifetime of the
    states as objects.}
    \label{fig:sequenceEmbedX}
\end{figure}

The operational class is where the internal statemachine gets activated by the \textit{onEntry} 
function inside the operational class. That signifies the start of the operational sequence diagram, seen on figure  \ref{fig:sequenceOperational}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.5\textwidth]{pictures/sequence_operational.png}
    \caption{The internal statemachine \textit{opFsm} inside operational, this is a concurrent
    statemachine to the on outside, however the two don't have any interplay.
    As with the outside statemachine, this also have classes as states, implemented by the 
    state/eventHandler mechanism, all are singletons aswell. All data passed through opFsm, are 
    referenced to the outside machine.}
    \label{fig:sequenceOperational}
\end{figure}

The important thing in this sequence diagram on figure \ref{fig:sequenceOperational} is, that the \textit{RealTimeLoop} is an 
active object, meaning that its method invocation has been decoupled from its exection, this
is also shown in figure \ref{fig:overallStatemachine}. Where to overall mechanism follow
the class diagram seen on figure \ref{fig:classActiveObject}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{pictures/state_active_object.png}
    \caption{The internal class diagram of the active object, which resides inside the 
    RealTimeLoop class}
    \label{fig:classActiveObject}
\end{figure}

As already mentioned, the active object decouples the execution from the invocation, meaning
that the caller or client is free to do whatever it wants in the meantime, so the call is non-blocking.
This is done through the \textit{std::future}, which is a pointer to a place where the work will,
at some point, be completed. This is part of the future/promise functionality in C++. 
The overall idea is that it is up to the \textit{Servant} to \textit{fullfill the promise} of the future.
\\
The sequence diagram for the internal statemachine \textit{opFsm} can be found below

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{pictures/sequence_configuration.png}
    \caption{opFsm, statemachine sequence diagram.}
    \label{fig:opfsmSequence}
\end{figure}

The essence of diagram shown in figure \ref{fig:opfsmSequence} is to show that there is two
statemachines working at the same time, independently of each other, however, there are not conflicting states between them.
The heavy lifting is done by the handleEvent function in operational, that passes any event that does not belong
to the outer statemachine, to the inner statemachine.

The case in figure \ref{fig:opfsmSequence} is where the user wants to order work, ie. in this project, this
is done by pseudo-work, were a enum state inside \textit{RTLservant} is changed, according to the allowed states.

\subsubsection{Active Object}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{pictures/sequence_RealTimeLoop.png}
    \caption{internal sequence diagram for RealTimeLoop}
    \label{fig:sequenceRealTimeLoop}
\end{figure}

The internal sequence diagram for RealTimeLoop is shown in figure \ref{fig:sequenceRealTimeLoop}, which is 
what happends when the diagram in figure \ref{fig:opfsmSequence} is executed. Thus the scheduler is 
"primed" in when entering the RealTimeLoop, however it does not do anything before the operational handleEvent
is called to request the actual work. 